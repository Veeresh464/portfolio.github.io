<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Bellman-Ford Algorithm</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet" />
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            margin: 0;
            background-color: #f8f9fa;
            color: #333;
        }

        header {
            background-color: #2d2d2d;
            color: #fff;
            padding: 20px;
            text-align: center;
            border-bottom: 5px solid #0ea5e9;
        }

        main {
            max-width: 1000px;
            margin: 40px auto;
            padding: 0 20px;
        }

        h2 {
            color: #0ea5e9;
            border-left: 5px solid #0ea5e9;
            padding-left: 10px;
        }

        section {
            margin-bottom: 40px;
        }

        ul {
            list-style-type: square;
            padding-left: 20px;
        }

        ul li {
            margin-bottom: 10px;
        }

        .code-link {
            display: inline-block;
            background-color: #0ea5e9;
            color: #fff;
            padding: 10px 20px;
            text-decoration: none;
            border-radius: 5px;
            transition: background-color 0.3s ease;
        }

        .code-link:hover {
            background-color: #0284c7;
        }

        .algorithm-advantages {
            background: rgba(0, 0, 0, 0.03);
            padding: 25px;
            border-radius: 10px;
            margin-top: 20px;
            border-left: 4px solid #0ea5e9;
        }

        .component-subtitle {
            font-size: 1.2rem;
            color: #0ea5e9;
            margin: 20px 0 10px 0;
            font-weight: 600;
        }

        footer {
            text-align: center;
            padding: 20px;
            background-color: #2d2d2d;
            color: #ccc;
        }
    </style>
</head>

<body>
    <header>
        <h1>Bellman-Ford Algorithm</h1>
    </header>

    <main>
        <section>
            <h2>Description</h2>
            <p>
                A* search algorithm is a path finding algorithm that finds the single-pair shortest path between the
                start node(source) and the target node(destination) of a weighted graph. The algorithm not only
                considers the actual cost from the start node to the current node(g) but also tries to estimate the cost
                will take from the current node to the target node using heuristics (h). Then it selects the node that
                has the lowest f-value(f=g+h) to be the next node to move until it hits the target node. Dijkstraâ€™s
                algorithm is a special case of A* algorithm where heuristic is 0 for all nodes.
            </p>
        </section>

        <iframe width="560" height="315" src="https://www.youtube.com/embed/g024lzsknDo?si=lqQbR0t0d_JS2X5e" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>


        <section>
            <h2>Key Features</h2>
            <ul>
                <li><strong>Heuristic-Driven Efficiency:</strong> Uses informed estimates to guide the search,
                    significantly reducing the number of nodes explored compared to uninformed algorithms.</li>
                <li><strong>Optimal and Complete:</strong> Guarantees finding the shortest path if the heuristic is
                    admissible (never overestimates the true cost).</li>
                <li><strong>Dynamic Adaptability:</strong> Easily recalculates routes in response to network topology
                    changes or varying traffic loads, ideal for real-time cloud environments.</li>
                <li><strong>Flexible Heuristic Design:</strong> Allows customization of heuristic functions to suit
                    specific metrics like latency, bandwidth, or cost in cloud infrastructure.</li>
            </ul>
        </section>


        <section>
            <h2>Use Case</h2>
            <p>
                A* algorithm is particularly well-suited for routing and resource allocation in cloud platforms such as
                OpenStack and GCP. It ensures:
            </p>
            <ul>
                <li>Fast and efficient VM placement by quickly finding the shortest path between compute nodes and user
                    endpoints.</li>
                <li>Optimized network routing that reduces latency and bandwidth consumption in large, dynamic cloud
                    topologies.</li>
                <li>Real-time adaptation to changing network conditions, supporting dynamic workloads and multi-tenant
                    environments.</li>
            </ul>
        </section>


        <section>
            <h2>Implementation</h2>
            <p>
                Below is the implimentation of A* algorithm.
            </p>
            <a class="code-link"
                href="https://leetcode.com/problems/network-delay-time/submissions/1595131537/">A*
                Implementation in Java</a>
        </section>

        <section>
            <h2>References</h2>
            <ul>
                <li><strong>Medium: </strong> https://yuminlee2.medium.com/a-search-algorithm-42c1a13fcf9f#5ca4</li>
                <li><strong>Wikipedia: </strong> https://en.wikipedia.org/wiki/A*_search_algorithm</li>
                <li><strong>Visulization: </strong> https://see-algorithms.com/graph/TopSort</li>
                <li><strong>Youtube: </strong>https://www.youtube.com/watch?v=g024lzsknDo</li>
            </ul>
        </section>
    </main>
</body>

</html>